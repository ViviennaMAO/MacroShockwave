# MacroShockwave 技术架构设计

## 文档信息
- **版本**：V1.0
- **最后更新**：2026-01-17
- **技术负责人**：待定

---

## 目录
1. [系统架构概览](#1-系统架构概览)
2. [前端架构](#2-前端架构)
3. [后端架构](#3-后端架构)
4. [智能合约架构](#4-智能合约架构)
5. [数据库设计](#5-数据库设计)
6. [API 设计](#6-api-设计)
7. [部署架构](#7-部署架构)

---

## 1. 系统架构概览

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                         用户层                               │
│  ┌──────────────┐         ┌──────────────┐                 │
│  │  Luffa App   │         │   浏览器     │                 │
│  │  (小程序容器) │         │  (Web端)     │                 │
│  └──────┬───────┘         └──────┬───────┘                 │
└─────────┼──────────────────────┼───────────────────────────┘
          │                      │
          └──────────┬───────────┘
                     │
┌────────────────────▼──────────────────────────────────────┐
│                    前端应用层                              │
│  ┌──────────────────────────────────────────────────────┐ │
│  │  React 18 + TypeScript + Tailwind CSS               │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │ │
│  │  │ 事件面板  │  │ Portfolio│  │  Profile │          │ │
│  │  └──────────┘  └──────────┘  └──────────┘          │ │
│  │  ┌──────────────────────────────────────┐          │ │
│  │  │     Zustand (状态管理)                │          │ │
│  │  └──────────────────────────────────────┘          │ │
│  │  ┌──────────────────────────────────────┐          │ │
│  │  │     Luffa SDK (钱包集成)              │          │ │
│  │  └──────────────────────────────────────┘          │ │
│  └──────────────────────────────────────────────────────┘ │
└────────────────────┬──────────────────────────────────────┘
                     │
          ┌──────────┼──────────┐
          │          │          │
          ▼          ▼          ▼
┌─────────────┐ ┌─────────┐ ┌──────────────┐
│   后端 API  │ │ 区块链   │ │  数据服务    │
└─────────────┘ └─────────┘ └──────────────┘
          │          │          │
┌─────────▼──────────▼──────────▼──────────────────────────┐
│                    服务层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │  REST API    │  │ 智能合约      │  │ Oracle 服务  │   │
│  │ (Node.js)    │  │ (Solidity)   │  │ (Chainlink)  │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │  WebSocket   │  │ 价格聚合      │  │ 数据抓取     │   │
│  │  (实时推送)  │  │ (多源验证)    │  │ (宏观数据)   │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└────────────────────┬──────────────────────────────────────┘
                     │
┌────────────────────▼──────────────────────────────────────┐
│                    数据层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │  PostgreSQL  │  │    Redis     │  │  IPFS (可选) │   │
│  │  (主数据库)  │  │   (缓存)     │  │  (存储证据)  │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└───────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────┐
│                    外部服务                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │  Binance API │  │ Trading Econ │  │  Federal     │   │
│  │  (BTC价格)   │  │  (宏观数据)  │  │  Reserve API │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└───────────────────────────────────────────────────────────┘
```

### 1.2 技术栈总览

#### 前端
```yaml
框架: React 18.2+
语言: TypeScript 5.0+
样式: Tailwind CSS 3.4+
状态管理: Zustand 4.0+
路由: React Router 6.0+
UI组件: Radix UI
动画: Framer Motion 10.0+
图表: Recharts 2.0+
工具:
  - Vite (构建工具)
  - ESLint + Prettier (代码规范)
  - Vitest (单元测试)
```

#### 后端
```yaml
运行时: Node.js 20 LTS
框架: Express 4.18+ / Nest.js 10+
语言: TypeScript 5.0+
数据库: PostgreSQL 15+
缓存: Redis 7.0+
消息队列: Bull (基于Redis)
工具:
  - Prisma (ORM)
  - Joi (数据验证)
  - Winston (日志)
  - Jest (测试)
```

#### 智能合约
```yaml
语言: Solidity 0.8.20+
框架: Hardhat / Foundry
测试: Hardhat Test / Forge
审计: Slither, Mythril
库:
  - OpenZeppelin Contracts
  - Chainlink (Oracle)
```

#### DevOps
```yaml
容器: Docker + Docker Compose
CI/CD: GitHub Actions
监控: Grafana + Prometheus
日志: ELK Stack
部署: AWS / GCP / Vercel
```

---

## 2. 前端架构

### 2.1 项目结构

```
src/
├── app/                    # 应用入口
│   ├── App.tsx
│   ├── main.tsx
│   └── routes.tsx
│
├── pages/                  # 页面组件
│   ├── Home/              # 首页 (事件列表)
│   │   ├── index.tsx
│   │   ├── EventCard.tsx
│   │   └── EventList.tsx
│   │
│   ├── EventDetail/       # 事件详情页
│   │   ├── index.tsx
│   │   ├── GameModeA.tsx  # 数据狙击手
│   │   ├── GameModeB.tsx  # 波动猎人
│   │   └── GameModeC.tsx  # 精准点位
│   │
│   ├── Portfolio/         # 投资组合
│   │   ├── index.tsx
│   │   ├── Overview.tsx
│   │   ├── Positions.tsx
│   │   ├── OpenOrders.tsx
│   │   └── History.tsx
│   │
│   └── Profile/           # 用户资料
│       ├── index.tsx
│       ├── Stats.tsx
│       └── Settings.tsx
│
├── components/            # 通用组件
│   ├── ui/               # UI 基础组件
│   │   ├── Button.tsx
│   │   ├── Card.tsx
│   │   ├── Modal.tsx
│   │   ├── Input.tsx
│   │   ├── Toast.tsx
│   │   └── Loading.tsx
│   │
│   ├── layout/           # 布局组件
│   │   ├── Header.tsx
│   │   ├── Navigation.tsx
│   │   └── Footer.tsx
│   │
│   └── business/         # 业务组件
│       ├── BetPanel.tsx
│       ├── OddsDisplay.tsx
│       ├── Countdown.tsx
│       └── PriceChart.tsx
│
├── stores/               # 状态管理
│   ├── useUserStore.ts   # 用户状态
│   ├── useEventStore.ts  # 事件状态
│   ├── useBetStore.ts    # 下注状态
│   └── useWalletStore.ts # 钱包状态
│
├── hooks/                # 自定义 Hooks
│   ├── useLuffa.ts       # Luffa SDK 集成
│   ├── useContract.ts    # 合约交互
│   ├── useWebSocket.ts   # 实时数据
│   └── useCountdown.ts   # 倒计时
│
├── services/             # 服务层
│   ├── api/              # API 调用
│   │   ├── events.ts
│   │   ├── bets.ts
│   │   └── users.ts
│   │
│   ├── contract/         # 合约交互
│   │   ├── betting.ts
│   │   └── settlement.ts
│   │
│   └── luffa/            # Luffa 集成
│       ├── wallet.ts
│       └── share.ts
│
├── utils/                # 工具函数
│   ├── format.ts         # 格式化
│   ├── calculate.ts      # 计算
│   ├── validate.ts       # 验证
│   └── constants.ts      # 常量
│
├── types/                # 类型定义
│   ├── event.ts
│   ├── bet.ts
│   ├── user.ts
│   └── contract.ts
│
└── assets/               # 静态资源
    ├── images/
    ├── icons/
    └── fonts/
```

### 2.2 核心功能模块

#### 2.2.1 Luffa SDK 集成

```typescript
// hooks/useLuffa.ts
import { useEffect, useState } from 'react';

interface LuffaAccount {
  address: string;
  username: string;
  avatar: string;
}

export function useLuffa() {
  const [account, setAccount] = useState<LuffaAccount | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    initLuffa();
  }, []);

  const initLuffa = async () => {
    try {
      if (typeof window.luffa === 'undefined') {
        console.error('Luffa SDK not found');
        setIsLoading(false);
        return;
      }

      const accountInfo = await window.luffa.getAccount();
      setAccount(accountInfo);
      setIsConnected(true);

      // 监听账户变化
      window.luffa.on('accountChanged', (newAccount: LuffaAccount) => {
        setAccount(newAccount);
      });
    } catch (error) {
      console.error('Failed to init Luffa:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const sendTransaction = async (params: {
    to: string;
    data: string;
    value: string;
  }) => {
    try {
      const tx = await window.luffa.sendTransaction(params);
      return { success: true, txHash: tx.hash };
    } catch (error) {
      return { success: false, error: (error as Error).message };
    }
  };

  const setShareInfo = (info: {
    title: string;
    description: string;
    imageUrl: string;
    path: string;
  }) => {
    if (window.luffa) {
      window.luffa.setShareInfo(info);
    }
  };

  return {
    account,
    isConnected,
    isLoading,
    sendTransaction,
    setShareInfo,
  };
}
```

#### 2.2.2 状态管理

```typescript
// stores/useBetStore.ts
import { create } from 'zustand';

interface BetState {
  selectedEvent: Event | null;
  selectedGameMode: 'A' | 'B' | 'C' | null;
  selectedOption: string | null;
  betAmount: string;

  setSelectedEvent: (event: Event) => void;
  setSelectedGameMode: (mode: 'A' | 'B' | 'C') => void;
  setSelectedOption: (option: string) => void;
  setBetAmount: (amount: string) => void;
  resetBet: () => void;
}

export const useBetStore = create<BetState>((set) => ({
  selectedEvent: null,
  selectedGameMode: null,
  selectedOption: null,
  betAmount: '',

  setSelectedEvent: (event) => set({ selectedEvent: event }),
  setSelectedGameMode: (mode) => set({ selectedGameMode: mode }),
  setSelectedOption: (option) => set({ selectedOption: option }),
  setBetAmount: (amount) => set({ betAmount: amount }),
  resetBet: () => set({
    selectedGameMode: null,
    selectedOption: null,
    betAmount: '',
  }),
}));
```

#### 2.2.3 实时数据更新

```typescript
// hooks/useWebSocket.ts
import { useEffect, useState } from 'react';

interface WSMessage {
  type: 'odds_update' | 'event_locked' | 'settlement' | 'pool_update';
  data: any;
}

export function useWebSocket(url: string) {
  const [ws, setWs] = useState<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const socket = new WebSocket(url);

    socket.onopen = () => {
      console.log('WebSocket connected');
      setIsConnected(true);
    };

    socket.onmessage = (event) => {
      const message: WSMessage = JSON.parse(event.data);
      handleMessage(message);
    };

    socket.onclose = () => {
      console.log('WebSocket disconnected');
      setIsConnected(false);
      // 重连逻辑
      setTimeout(() => setWs(new WebSocket(url)), 5000);
    };

    setWs(socket);

    return () => {
      socket.close();
    };
  }, [url]);

  const handleMessage = (message: WSMessage) => {
    switch (message.type) {
      case 'odds_update':
        // 更新赔率
        break;
      case 'pool_update':
        // 更新奖金池
        break;
      case 'event_locked':
        // 事件锁定
        break;
      case 'settlement':
        // 结算完成
        break;
    }
  };

  return { ws, isConnected };
}
```

---

## 3. 后端架构

### 3.1 项目结构

```
backend/
├── src/
│   ├── modules/              # 功能模块
│   │   ├── events/           # 事件管理
│   │   │   ├── events.controller.ts
│   │   │   ├── events.service.ts
│   │   │   ├── events.dto.ts
│   │   │   └── events.entity.ts
│   │   │
│   │   ├── bets/             # 下注管理
│   │   │   ├── bets.controller.ts
│   │   │   ├── bets.service.ts
│   │   │   ├── bets.dto.ts
│   │   │   └── bets.entity.ts
│   │   │
│   │   ├── users/            # 用户管理
│   │   │   ├── users.controller.ts
│   │   │   ├── users.service.ts
│   │   │   └── users.entity.ts
│   │   │
│   │   ├── settlement/       # 结算服务
│   │   │   ├── settlement.service.ts
│   │   │   └── settlement.worker.ts
│   │   │
│   │   └── oracle/           # Oracle 服务
│   │       ├── oracle.service.ts
│   │       ├── price-oracle.ts
│   │       └── data-oracle.ts
│   │
│   ├── common/               # 通用模块
│   │   ├── decorators/
│   │   ├── filters/
│   │   ├── guards/
│   │   ├── interceptors/
│   │   └── pipes/
│   │
│   ├── config/               # 配置
│   │   ├── database.config.ts
│   │   ├── redis.config.ts
│   │   └── blockchain.config.ts
│   │
│   ├── jobs/                 # 定时任务
│   │   ├── data-fetcher.job.ts
│   │   ├── price-updater.job.ts
│   │   └── settlement.job.ts
│   │
│   └── utils/                # 工具函数
│       ├── logger.ts
│       ├── calculator.ts
│       └── validator.ts
│
├── prisma/                   # Prisma ORM
│   ├── schema.prisma
│   └── migrations/
│
├── test/                     # 测试
│   ├── unit/
│   └── e2e/
│
└── docker/                   # Docker 配置
    ├── Dockerfile
    └── docker-compose.yml
```

### 3.2 核心服务

#### 3.2.1 事件管理服务

```typescript
// modules/events/events.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { RedisService } from '../redis/redis.service';

@Injectable()
export class EventsService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  async getUpcomingEvents() {
    // 先从缓存获取
    const cached = await this.redis.get('events:upcoming');
    if (cached) return JSON.parse(cached);

    // 数据库查询
    const events = await this.prisma.event.findMany({
      where: {
        releaseTime: { gte: new Date() },
        status: { in: ['OPEN', 'BETTING'] },
      },
      orderBy: { releaseTime: 'asc' },
      include: {
        pools: true, // 包含奖金池信息
      },
    });

    // 缓存 30 秒
    await this.redis.set(
      'events:upcoming',
      JSON.stringify(events),
      'EX',
      30
    );

    return events;
  }

  async getEventDetail(eventId: string) {
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
      include: {
        pools: {
          include: {
            options: true, // 包含各选项的下注情况
          },
        },
      },
    });

    if (!event) throw new Error('Event not found');

    // 计算实时赔率
    const oddsMap = this.calculateOdds(event.pools);

    return {
      ...event,
      odds: oddsMap,
    };
  }

  private calculateOdds(pools: any[]) {
    const oddsMap = {};

    pools.forEach(pool => {
      const totalPool = pool.totalAmount * 0.97; // 扣除3%手续费

      pool.options.forEach(option => {
        if (option.totalAmount > 0) {
          oddsMap[option.id] = totalPool / option.totalAmount;
        } else {
          oddsMap[option.id] = 0;
        }
      });
    });

    return oddsMap;
  }
}
```

#### 3.2.2 下注服务

```typescript
// modules/bets/bets.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class BetsService {
  constructor(private prisma: PrismaService) {}

  async placeBet(dto: PlaceBetDto) {
    // 1. 验证下注金额
    this.validateBetAmount(dto.amount);

    // 2. 检查用户限额
    await this.checkUserLimit(dto.userId, dto.eventId, dto.amount);

    // 3. 检查事件状态
    await this.checkEventStatus(dto.eventId);

    // 4. 创建订单（待确认）
    const order = await this.prisma.order.create({
      data: {
        userId: dto.userId,
        eventId: dto.eventId,
        gameMode: dto.gameMode,
        optionId: dto.optionId,
        amount: dto.amount,
        status: 'PENDING',
      },
    });

    return order;
  }

  async confirmBet(orderId: string, txHash: string) {
    // 验证链上交易
    const isValid = await this.verifyTransaction(txHash);
    if (!isValid) throw new Error('Invalid transaction');

    // 更新订单状态
    const order = await this.prisma.order.update({
      where: { id: orderId },
      data: {
        status: 'CONFIRMED',
        txHash,
        confirmedAt: new Date(),
      },
    });

    // 更新奖金池
    await this.updatePool(order);

    // 推送实时更新
    await this.broadcastPoolUpdate(order.eventId);

    return order;
  }

  private validateBetAmount(amount: number) {
    if (amount < 10) throw new Error('Minimum bet is 10 USDT');
    if (amount > 10000) throw new Error('Maximum bet is 10,000 USDT');
  }

  private async checkUserLimit(
    userId: string,
    eventId: string,
    newAmount: number
  ) {
    const userTotal = await this.prisma.order.aggregate({
      where: {
        userId,
        eventId,
        status: { in: ['CONFIRMED', 'PENDING'] },
      },
      _sum: { amount: true },
    });

    const total = (userTotal._sum.amount || 0) + newAmount;
    if (total > 50000) {
      throw new Error('User limit exceeded (50,000 USDT per event)');
    }
  }

  private async checkEventStatus(eventId: string) {
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
    });

    if (!event) throw new Error('Event not found');

    const now = new Date();
    const lockTime = new Date(event.releaseTime.getTime() - 5 * 60 * 1000);

    if (now >= lockTime) {
      throw new Error('Betting is closed');
    }
  }
}
```

#### 3.2.3 结算服务

```typescript
// modules/settlement/settlement.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { OracleService } from '../oracle/oracle.service';

@Injectable()
export class SettlementService {
  constructor(
    private prisma: PrismaService,
    private oracle: OracleService,
  ) {}

  async settleEvent(eventId: string) {
    console.log(`Starting settlement for event ${eventId}`);

    // 1. 获取 Oracle 数据
    const oracleData = await this.oracle.getEventResult(eventId);
    if (!oracleData.isValid) {
      throw new Error('Invalid oracle data');
    }

    // 2. 获取事件信息
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
      include: {
        pools: {
          include: {
            options: {
              include: {
                orders: true,
              },
            },
          },
        },
      },
    });

    // 3. 根据玩法类型结算
    for (const pool of event.pools) {
      await this.settlePool(pool, oracleData);
    }

    // 4. 更新事件状态
    await this.prisma.event.update({
      where: { id: eventId },
      data: { status: 'SETTLED', settledAt: new Date() },
    });

    console.log(`Settlement completed for event ${eventId}`);
  }

  private async settlePool(pool: any, oracleData: any) {
    const gameMode = pool.gameMode;

    // 确定获胜选项
    let winningOptionId: string | null = null;

    if (gameMode === 'A') {
      // 数据狙击手
      winningOptionId = this.determineWinnerModeA(pool, oracleData);
    } else if (gameMode === 'B') {
      // 波动猎人
      winningOptionId = this.determineWinnerModeB(pool, oracleData);
    } else if (gameMode === 'C') {
      // 精准点位
      winningOptionId = this.determineWinnerModeC(pool, oracleData);
    }

    // 如果无人中奖（仅玩法C可能）
    if (!winningOptionId) {
      await this.refundAll(pool);
      return;
    }

    // 计算并分配奖金
    await this.distributeWinnings(pool, winningOptionId);
  }

  private determineWinnerModeA(pool: any, oracleData: any) {
    const { consensusValue, publishedValue, tolerance } = oracleData;

    if (publishedValue < consensusValue - tolerance) {
      return pool.options.find(o => o.type === 'DOVISH')?.id;
    } else if (publishedValue > consensusValue + tolerance) {
      return pool.options.find(o => o.type === 'HAWKISH')?.id;
    } else {
      return pool.options.find(o => o.type === 'NEUTRAL')?.id;
    }
  }

  private async distributeWinnings(pool: any, winningOptionId: string) {
    const totalPool = pool.totalAmount * 0.97; // 扣除3%手续费
    const winningOption = pool.options.find(o => o.id === winningOptionId);
    const winningTotal = winningOption.totalAmount;

    // 批量更新获胜订单
    for (const order of winningOption.orders) {
      const winnings = (order.amount / winningTotal) * totalPool;

      await this.prisma.order.update({
        where: { id: order.id },
        data: {
          status: 'WON',
          winnings,
          settledAt: new Date(),
        },
      });

      // 自动转账给用户（调用合约）
      await this.transferWinnings(order.userId, winnings);
    }

    // 更新失败订单
    const losingOrders = pool.options
      .filter(o => o.id !== winningOptionId)
      .flatMap(o => o.orders);

    for (const order of losingOrders) {
      await this.prisma.order.update({
        where: { id: order.id },
        data: {
          status: 'LOST',
          winnings: 0,
          settledAt: new Date(),
        },
      });
    }
  }

  private async refundAll(pool: any) {
    // 无人中奖，全额退款
    for (const option of pool.options) {
      for (const order of option.orders) {
        await this.prisma.order.update({
          where: { id: order.id },
          data: {
            status: 'REFUNDED',
            winnings: order.amount, // 全额退款
            settledAt: new Date(),
          },
        });

        await this.transferWinnings(order.userId, order.amount);
      }
    }
  }
}
```

---

## 4. 智能合约架构

### 4.1 合约结构

```
contracts/
├── core/
│   ├── MacroShockwave.sol      # 主合约
│   ├── BettingPool.sol          # 奖金池合约
│   └── Settlement.sol           # 结算合约
│
├── oracle/
│   ├── DataOracle.sol           # 数据预言机
│   └── PriceOracle.sol          # 价格预言机
│
├── governance/
│   ├── Timelock.sol             # 时间锁
│   └── MultiSig.sol             # 多签
│
├── libraries/
│   ├── OddsCalculator.sol       # 赔率计算
│   └── SafeTransfer.sol         # 安全转账
│
└── interfaces/
    ├── IMacroShockwave.sol
    └── IOracle.sol
```

### 4.2 主合约设计

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract MacroShockwave is ReentrancyGuard, Pausable, AccessControl {
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    uint256 public constant PLATFORM_FEE_RATE = 300; // 3% (基点)
    uint256 public constant MIN_BET = 10 ether; // 10 USDT
    uint256 public constant MAX_BET = 10000 ether; // 10,000 USDT
    uint256 public constant MAX_USER_BET_PER_EVENT = 50000 ether;
    uint256 public constant LOCK_TIME_BEFORE_RELEASE = 5 minutes;

    struct Event {
        uint256 id;
        string name;
        uint256 releaseTime;
        EventStatus status;
        uint256 settledAt;
    }

    struct Pool {
        uint256 eventId;
        GameMode gameMode;
        uint256 totalAmount;
        mapping(uint256 => Option) options;
        uint256 optionCount;
    }

    struct Option {
        uint256 id;
        string name;
        uint256 totalAmount;
        uint256[] orderIds;
    }

    struct Order {
        uint256 id;
        address user;
        uint256 eventId;
        GameMode gameMode;
        uint256 optionId;
        uint256 amount;
        uint256 winnings;
        OrderStatus status;
        uint256 createdAt;
    }

    enum EventStatus { OPEN, BETTING, LOCKED, SETTLING, SETTLED }
    enum GameMode { DATA_SNIPER, VOLATILITY_HUNTER, JACKPOT }
    enum OrderStatus { PENDING, CONFIRMED, WON, LOST, REFUNDED }

    mapping(uint256 => Event) public events;
    mapping(uint256 => Pool) public pools;
    mapping(uint256 => Order) public orders;
    mapping(address => mapping(uint256 => uint256)) public userBetAmounts;

    uint256 public nextEventId = 1;
    uint256 public nextOrderId = 1;

    event BetPlaced(
        uint256 indexed orderId,
        address indexed user,
        uint256 indexed eventId,
        GameMode gameMode,
        uint256 optionId,
        uint256 amount
    );

    event EventSettled(
        uint256 indexed eventId,
        uint256 indexed winningOptionId
    );

    event WinningsDistributed(
        uint256 indexed orderId,
        address indexed user,
        uint256 amount
    );

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    /**
     * @dev 用户下注
     */
    function placeBet(
        uint256 eventId,
        GameMode gameMode,
        uint256 optionId,
        uint256 amount
    ) external payable nonReentrant whenNotPaused returns (uint256) {
        // 验证金额
        require(amount >= MIN_BET, "Below minimum bet");
        require(amount <= MAX_BET, "Exceeds maximum bet");
        require(msg.value >= amount, "Insufficient payment");

        // 验证用户限额
        uint256 userTotal = userBetAmounts[msg.sender][eventId] + amount;
        require(userTotal <= MAX_USER_BET_PER_EVENT, "User limit exceeded");

        // 验证事件状态
        Event storage evt = events[eventId];
        require(evt.status == EventStatus.BETTING, "Event not open");
        require(
            block.timestamp < evt.releaseTime - LOCK_TIME_BEFORE_RELEASE,
            "Betting closed"
        );

        // 创建订单
        uint256 orderId = nextOrderId++;
        orders[orderId] = Order({
            id: orderId,
            user: msg.sender,
            eventId: eventId,
            gameMode: gameMode,
            optionId: optionId,
            amount: amount,
            winnings: 0,
            status: OrderStatus.CONFIRMED,
            createdAt: block.timestamp
        });

        // 更新奖金池
        Pool storage pool = pools[eventId];
        pool.totalAmount += amount;
        pool.options[optionId].totalAmount += amount;
        pool.options[optionId].orderIds.push(orderId);

        // 更新用户总下注
        userBetAmounts[msg.sender][eventId] = userTotal;

        emit BetPlaced(orderId, msg.sender, eventId, gameMode, optionId, amount);

        return orderId;
    }

    /**
     * @dev 结算事件 (仅 Oracle 可调用)
     */
    function settleEvent(
        uint256 eventId,
        uint256 winningOptionId
    ) external onlyRole(ORACLE_ROLE) {
        Event storage evt = events[eventId];
        require(evt.status == EventStatus.LOCKED, "Event not locked");

        Pool storage pool = pools[eventId];
        uint256 totalPool = pool.totalAmount * (10000 - PLATFORM_FEE_RATE) / 10000;

        Option storage winningOption = pool.options[winningOptionId];

        // 如果无人中奖（仅精准点位可能）
        if (winningOption.totalAmount == 0) {
            _refundAll(pool);
        } else {
            _distributeWinnings(pool, winningOption, totalPool);
        }

        evt.status = EventStatus.SETTLED;
        evt.settledAt = block.timestamp;

        emit EventSettled(eventId, winningOptionId);
    }

    /**
     * @dev 分配奖金
     */
    function _distributeWinnings(
        Pool storage pool,
        Option storage winningOption,
        uint256 totalPool
    ) private {
        uint256 winningTotal = winningOption.totalAmount;

        for (uint256 i = 0; i < winningOption.orderIds.length; i++) {
            uint256 orderId = winningOption.orderIds[i];
            Order storage order = orders[orderId];

            uint256 winnings = (order.amount * totalPool) / winningTotal;
            order.winnings = winnings;
            order.status = OrderStatus.WON;

            // 自动转账
            payable(order.user).transfer(winnings);

            emit WinningsDistributed(orderId, order.user, winnings);
        }
    }

    /**
     * @dev 全额退款
     */
    function _refundAll(Pool storage pool) private {
        for (uint256 i = 0; i < pool.optionCount; i++) {
            Option storage option = pool.options[i];

            for (uint256 j = 0; j < option.orderIds.length; j++) {
                uint256 orderId = option.orderIds[j];
                Order storage order = orders[orderId];

                order.winnings = order.amount;
                order.status = OrderStatus.REFUNDED;

                payable(order.user).transfer(order.amount);
            }
        }
    }

    /**
     * @dev 紧急暂停
     */
    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
    }
}
```

---

## 5. 数据库设计

### 5.1 Prisma Schema

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  address   String   @unique
  username  String?
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  stats     UserStats?

  @@index([address])
}

model UserStats {
  id           String   @id @default(cuid())
  userId       String   @unique
  user         User     @relation(fields: [userId], references: [id])

  totalBets    Int      @default(0)
  totalWins    Int      @default(0)
  totalLosses  Int      @default(0)
  totalAmount  Decimal  @default(0) @db.Decimal(20, 2)
  totalWinnings Decimal @default(0) @db.Decimal(20, 2)
  winRate      Decimal  @default(0) @db.Decimal(5, 2)

  updatedAt    DateTime @updatedAt
}

model Event {
  id            String      @id @default(cuid())
  name          String
  type          EventType
  releaseTime   DateTime
  consensusValue Decimal?   @db.Decimal(10, 2)
  publishedValue Decimal?   @db.Decimal(10, 2)
  tolerance     Decimal?    @db.Decimal(10, 2)
  status        EventStatus @default(OPEN)
  settledAt     DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  pools         Pool[]
  orders        Order[]

  @@index([releaseTime])
  @@index([status])
}

enum EventType {
  CPI
  NFP
  GDP
  FED_RATE
}

enum EventStatus {
  OPEN
  BETTING
  LOCKED
  SETTLING
  SETTLED
}

model Pool {
  id          String    @id @default(cuid())
  eventId     String
  event       Event     @relation(fields: [eventId], references: [id])
  gameMode    GameMode
  totalAmount Decimal   @default(0) @db.Decimal(20, 2)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  options     Option[]

  @@unique([eventId, gameMode])
  @@index([eventId])
}

enum GameMode {
  DATA_SNIPER
  VOLATILITY_HUNTER
  JACKPOT
}

model Option {
  id          String   @id @default(cuid())
  poolId      String
  pool        Pool     @relation(fields: [poolId], references: [id])
  name        String
  type        String   // DOVISH, NEUTRAL, HAWKISH, etc.
  totalAmount Decimal  @default(0) @db.Decimal(20, 2)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orders      Order[]

  @@index([poolId])
}

model Order {
  id          String      @id @default(cuid())
  userId      String
  user        User        @relation(fields: [userId], references: [id])
  eventId     String
  event       Event       @relation(fields: [eventId], references: [id])
  optionId    String
  option      Option      @relation(fields: [optionId], references: [id])
  gameMode    GameMode
  amount      Decimal     @db.Decimal(20, 2)
  winnings    Decimal     @default(0) @db.Decimal(20, 2)
  status      OrderStatus @default(PENDING)
  txHash      String?
  confirmedAt DateTime?
  settledAt   DateTime?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@index([userId])
  @@index([eventId])
  @@index([status])
  @@index([createdAt])
}

enum OrderStatus {
  PENDING
  CONFIRMED
  WON
  LOST
  REFUNDED
}

model OracleData {
  id             String   @id @default(cuid())
  eventId        String
  dataType       String   // MACRO_DATA, BTC_PRICE
  value          Decimal  @db.Decimal(20, 8)
  source         String
  timestamp      DateTime
  isVerified     Boolean  @default(false)
  createdAt      DateTime @default(now())

  @@index([eventId])
  @@index([timestamp])
}
```

---

## 6. API 设计

### 6.1 RESTful API 端点

#### 事件相关

```
GET    /api/events               # 获取即将发布的事件列表
GET    /api/events/:id           # 获取事件详情
GET    /api/events/:id/pools     # 获取事件的所有奖金池
GET    /api/events/:id/odds      # 获取实时赔率
```

#### 下注相关

```
POST   /api/bets                 # 创建下注订单
GET    /api/bets/:id             # 获取订单详情
POST   /api/bets/:id/confirm     # 确认订单（提交 txHash）
```

#### 用户相关

```
GET    /api/users/me             # 获取当前用户信息
GET    /api/users/me/orders      # 获取用户订单列表
GET    /api/users/me/stats       # 获取用户统计数据
GET    /api/users/me/portfolio   # 获取投资组合
```

#### WebSocket 实时数据

```
WS     /ws/events/:id            # 订阅事件实时更新
WS     /ws/odds/:eventId         # 订阅赔率实时更新
```

### 6.2 API 响应示例

```json
// GET /api/events/:id

{
  "success": true,
  "data": {
    "id": "evt_123",
    "name": "CPI (Consumer Price Index)",
    "type": "CPI",
    "releaseTime": "2026-02-14T21:30:00Z",
    "consensusValue": 3.2,
    "status": "BETTING",
    "countdown": 172800,
    "pools": [
      {
        "gameMode": "DATA_SNIPER",
        "totalAmount": 30000,
        "participantCount": 245,
        "options": [
          {
            "id": "opt_1",
            "name": "Dovish",
            "type": "DOVISH",
            "totalAmount": 10000,
            "odds": 2.91
          },
          {
            "id": "opt_2",
            "name": "Neutral",
            "type": "NEUTRAL",
            "totalAmount": 5000,
            "odds": 5.82
          },
          {
            "id": "opt_3",
            "name": "Hawkish",
            "type": "HAWKISH",
            "totalAmount": 15000,
            "odds": 1.94
          }
        ]
      }
    ]
  }
}
```

---

## 7. 部署架构

### 7.1 生产环境架构

```
                        ┌─────────────────┐
                        │   Cloudflare    │
                        │   CDN + WAF     │
                        └────────┬────────┘
                                 │
                ┌────────────────┼────────────────┐
                │                │                │
         ┌──────▼──────┐  ┌─────▼─────┐  ┌──────▼──────┐
         │   Vercel    │  │    AWS    │  │  Infura /   │
         │  (前端)     │  │  (后端)   │  │ QuickNode   │
         │             │  │           │  │  (区块链)   │
         └─────────────┘  └─────┬─────┘  └─────────────┘
                                │
                    ┌───────────┼───────────┐
                    │           │           │
             ┌──────▼─────┐ ┌──▼────┐ ┌───▼─────┐
             │ PostgreSQL │ │ Redis │ │  ELK    │
             │   (RDS)    │ │       │ │ (日志)  │
             └────────────┘ └───────┘ └─────────┘
```

### 7.2 Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - VITE_API_URL=http://backend:4000
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "4000:4000"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/macroshockwave
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15-alpine
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=macroshockwave
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

---

**文档完成时间**：2026-01-17
**下一步**：开始实际开发实现
